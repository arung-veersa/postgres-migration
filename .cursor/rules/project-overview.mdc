---
description: Postgres migration repo structure - each ScriptsNN folder is an independent mini-project
alwaysApply: true
---

# Postgres Migration Repository

## Structure

This repo contains independent mini-projects in `ScriptsNN/` folders. Each is a self-contained proof-of-concept or migration task. They do NOT share code.

- `Scripts04/` - Initial migration program
- `Scripts05/` - Migration framework (superseded)
- `Scripts06-Analytics/` - Analytics views and PHP scripts
- `Scripts07/` - Data migration
- `Scripts08/` - S3 data migration
- `Scripts09/` - SQL task scripts
- `Scripts10-CrossState/` - Cross-state conflict cleanup
- `Scripts12/` - Task 02 Conflict Detection Lambda (Snowflake + PostgreSQL) -- **v3 UPDATE+stale cleanup complete, frozen**
- `Scripts13/` - **Active**: Task 02 Conflict Detection containerized for AWS ECS/ECR (copied from Scripts12, evolving)

## Conventions

- Python 3.11 runtime
- SQL templates loaded from `sql/` dirs, parameterized with `.format()`
- Config via `config/config.json` with `${ENV_VAR}` placeholders

## Scripts12 → Scripts13 Migration Context

Scripts13 was copied from Scripts12 and repackaged as a **Docker container** deployable via AWS Elastic Container Service (ECS) with images stored in AWS Elastic Container Registry (ECR). This removes the 15-minute Lambda timeout constraint and enables longer-running operations.

### What's done in Scripts13 (ECS):
- v3 multi-step Snowflake query architecture (delta_keys → base_visits → self-join)
- Asymmetric join with is_delta flag optimization
- Streaming cursor + 5K-row batch processing with commit-per-batch
- Conditional flag updates (7 flags: only N→Y, StatusFlag W/I preserved)
- Pair-precise stale cleanup (12.5M pairs, seen-based anti-join, StatusFlag='R')
- Change detection (_has_changes: 7 flags + 40 business columns)
- Excluded SSNs loaded from PostgreSQL into Snowflake temp table
- Column name mapping (ETATravleMinutes→ETATravelMinutes, SchVisitTimeSame→SchAndVisitTimeSameFlag)
- 81 pytest tests covering all of the above
- **Docker/ECS containerization complete**: Dockerfile, ECS task definition, ECR deployment
- **Container entry point** (`scripts/main.py`): comma-separated ACTION env var, DEFAULT_ACTIONS pipeline, SIGTERM graceful shutdown
- **Modular action architecture**: main.py is a lean orchestrator; each action in `scripts/actions/<key>.py` with `run_<key>()` naming convention
- **JSON-safe env var substitution** in `settings.py` (handles RSA keys with newlines)
- **Interactive deploy script** (`deploy/build-and-push-ecr.ps1`): SSO login, Docker build, ECR push, **task definition registration** (template + `.env` -> resolved JSON -> `aws ecs register-task-definition`), ECS run with action overrides
- **Deploy .env pattern**: `deploy/.env.example` template, `deploy/.env` for secrets (gitignored), `deploy/.generated-taskdef.json` output (gitignored)
- **Preflight/Postflight actions**: `task00_preflight` (validate config, verify connectivity, check tables, disable pg_cron, set InProgressFlag=1, capture row counts) and `task99_postflight` (VACUUM/ANALYZE, clear InProgressFlag, refresh materialized view, re-enable pg_cron, capture row counts, log pipeline summary, SES email)
- **task01_copy_to_staging**: Sync payer_provider_reminders from Snowflake dims (temp-table + UPDATE FROM JOIN, ~3s for 20K records) and truncate+populate conflictlog_staging from conflictvisitmaps+conflicts (~280s for 8M rows)
- **Pipeline summary logging**: Plain-text summary always logged to CloudWatch (independent of email)
- **Email notifications**: `lib/email_sender.py` sends HTML pipeline status reports via AWS SES (matching Snowflake email format)
- Successfully deployed and tested on ECS Fargate (~14 min full pipeline with task01)

### What's NOT yet done (to be implemented in Scripts13):
- INSERT logic for new conflicts (~102K detected but not inserted per run)
- Conflicts table aggregation
- UpdateFlag cleanup
- AWS Secrets Manager integration (currently using plain environment variables)
