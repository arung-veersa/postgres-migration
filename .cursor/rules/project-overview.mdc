---
description: Postgres migration repo structure - each ScriptsNN folder is an independent mini-project
alwaysApply: true
---

# Postgres Migration Repository

## Structure

This repo contains independent mini-projects in `ScriptsNN/` folders. Each is a self-contained proof-of-concept or migration task. They do NOT share code.

- `Scripts04/` - Initial migration program
- `Scripts05/` - Migration framework (superseded)
- `Scripts06-Analytics/` - Analytics views and PHP scripts
- `Scripts07/` - Data migration
- `Scripts08/` - S3 data migration
- `Scripts09/` - SQL task scripts
- `Scripts10-CrossState/` - Cross-state conflict cleanup
- `Scripts12/` - Task 02 Conflict Detection Lambda (Snowflake + PostgreSQL) -- **v3 UPDATE+stale cleanup complete, frozen**
- `Scripts13/` - **Active**: Task 02 Conflict Detection containerized for AWS ECS/ECR (copied from Scripts12, evolving)

## Conventions

- Python 3.11 runtime
- SQL templates loaded from `sql/` dirs, parameterized with `.format()`
- Config via `config/config.json` with `${ENV_VAR}` placeholders

## Scripts12 → Scripts13 Migration Context

Scripts13 was copied from Scripts12 and repackaged as a **Docker container** deployable via AWS Elastic Container Service (ECS) with images stored in AWS Elastic Container Registry (ECR). This removes the 15-minute Lambda timeout constraint and enables longer-running operations.

### What's done in Scripts13 (ECS):
- v3 multi-step Snowflake query architecture (delta_keys → base_visits → self-join)
- Asymmetric join with is_delta flag optimization
- Streaming cursor + 5K-row batch processing with commit-per-batch
- Conditional flag updates (7 flags: only N→Y, StatusFlag W/I preserved)
- Pair-precise stale cleanup (12.5M pairs, seen-based anti-join, StatusFlag='R')
- Change detection (_has_changes: 7 flags + 40 business columns)
- Excluded SSNs loaded from PostgreSQL into Snowflake temp table
- Column name mapping (ETATravleMinutes→ETATravelMinutes, SchVisitTimeSame→SchAndVisitTimeSameFlag)
- **Cross-state conflict filter**: Snowflake CTE excludes conflicts where no address state matches across sides (state normalization + provider fallback, matching SP_CLEANUP_CROSS_STATE_CONFLICTS)
- 210 pytest tests covering all of the above
- **Docker/ECS containerization complete**: Dockerfile, ECS task definition, ECR deployment
- **Container entry point** (`scripts/main.py`): comma-separated ACTION env var, DEFAULT_ACTIONS pipeline, SIGTERM graceful shutdown
- **Modular action architecture**: main.py is a lean orchestrator; each action in `scripts/actions/<key>.py` with `run_<key>()` naming convention
- **JSON-safe env var substitution** in `settings.py` (handles RSA keys with newlines)
- **Interactive deploy script** (`deploy/build-and-push-ecr.ps1`): SSO login, Docker build, ECR push, **task definition registration** (template + `.env` -> resolved JSON -> `aws ecs register-task-definition`), ECS run with action overrides
- **Deploy .env pattern**: `deploy/.env.example` template, `deploy/.env` for secrets (gitignored), `deploy/.generated-taskdef.json` output (gitignored)
- **Preflight/Postflight actions**: `task00_preflight` (validate config, verify connectivity, check tables, disable pg_cron, set InProgressFlag=1, sync identity sequences, VACUUM/ANALYZE, capture row counts) and `task99_postflight` (VACUUM/ANALYZE, clear InProgressFlag, refresh materialized view, re-enable pg_cron, capture row counts, log pipeline summary, SES email)
- **task01_copy_to_staging**: Sync payer_provider_reminders from Snowflake dims (temp-table + UPDATE FROM JOIN, ~3s for 20K records) and truncate+populate conflictlog_staging from conflictvisitmaps+conflicts (~280s for 8M rows)
- **Pipeline summary logging**: Plain-text summary always logged to CloudWatch (independent of email)
- **Email notifications**: `lib/email_sender.py` sends HTML pipeline status reports via AWS SES (matching Snowflake email format)
- **INSERT of new conflicts** integrated into streaming pass (StatusFlag='N', 206-column mapping, `enable_insert` config flag, self-healing PK retry)
- **InService conflict detection** (`task02_01_inservice_conflict`): visits vs InService events at different providers. 3-step Snowflake SQL (visits temp → events temp → UNION ALL pairs), temporal overlap join, synthetic MD5 VisitIDs, 7 flags hardcoded 'N', InServiceFlag='Y', UUID key normalisation (_norm_key), row-by-row insert fallback, caregiver semi-join optimisation. ~166K rows, ~14 min per run. Delta approach via FCS "Updated Date" deferred (acceptable runtime, low change frequency).
- **Status management & computed columns** (`task03_status_management`): Consolidates all post-conflict-creation processing from 3 Snowflake SPs. 15-step sequential executor (14 SQL + 1 fetch, 3 phases):
  - **Phase B** (Snowflake-dependent, 3 steps): Delta query on `FACTVISITCALLPERFORMANCE_DELETED_CR` using `"Visit Updated Timestamp"` + `lookback_hours` (shared via `common_parameters`) reduces 25.5M rows to ~84K. IDs loaded into indexed PG temp table with ANALYZE. UNION CTE marks CVM `StatusFlag='D'` when either VisitID or ConVisitID is deleted (hash-join-friendly, avoids OR-join nested-loop). Cascade to parent CF. Enabled by default (`enable_phase_b: true`). **Validated on ECS 2026-02-15**: 84K IDs, 3.3K CVM + 216 CF rows, 99.6s.
  - **Phase A** (pure PG status cascade, 9 steps): IsMissed cascade (CF+CVM), UpdateFlag orphan cleanup, aggregation (UpdatedRFlag + StatusFlag='U' propagation), CTE-driven combined CVM+CF cascade (singleton + near-all-resolved + all-resolved in 2 steps), NoResponseFlag reset (forced seq scan to avoid partial-index trap)
  - **Phase C** (computed columns, 3 steps): ShVTSTTime/CShVTSTTime (COALESCE of visit/sch/inservice times), BilledRateMinute/ConBilledRateMinute (rate-per-minute with ::real cast + epsilon comparison), ReverseUUID (canonical pair key, WHERE IS NULL optimisation)
  - All cascade steps preserve `StatusFlag='D'` (never overwrite D), commit per step, shutdown_check between steps, `only_steps` config for targeted execution
  - 68 pytest tests covering step definitions, SQL structure, Group B/A/C specifics, delta filter, executor logic, temp table, ANALYZE, forced seq scan, epsilon, ONLY_STEPS, UNION CTE guards, and statement timeout
- Successfully deployed and tested on ECS Fargate (~13 min full pipeline, ~21 min InService standalone)

### What's NOT yet done (to be implemented in Scripts13):
- AWS Secrets Manager integration (currently using plain environment variables)
